---
import type { Block, Post, ReferencesInPage } from "@/lib/interfaces";
import createMetascraper from "metascraper";
import metascraperDescription from "metascraper-description";
import metascraperImage from "metascraper-image";
import metascraperTitle from "metascraper-title";
import NBlocksPopover from "@/components/blog/references/NBlocksPopover.astro";
import { buildURLToHTMLMap, getReferenceLink } from "@/lib/blog-helpers";
import { REFERENCES } from "@/constants";
import Icon from "@/components/Icon.astro";

interface Props {
	post: Post;
	filteredReferencesInPage: ReferencesInPage[];
}
const { post, filteredReferencesInPage } = Astro.props;
const groupedReferences: { [key: string]: Block[] } = filteredReferencesInPage.reduce(
	(acc, ref) => {
		// Group by direct_nonmedia_link and collect Block objects
		if (ref.direct_nonmedia_link && !ref.direct_nonmedia_link.includes("tiktok.com")) {
			const key = ref.direct_nonmedia_link;
			acc[key] = acc[key] || [];
			acc[key].push(ref.block);
		}

		// Group by each Href in external_hrefs and collect Block objects
		ref.external_hrefs.forEach((richText) => {
			if (richText.Href && !richText.Href.includes("tiktok.com")) {
				const key = richText.Href;
				acc[key] = acc[key] || [];
				acc[key].push(ref.block);
			}
		});

		return acc;
	},
	{},
);

const blockIdLinks = {};
const urlList: URL[] = [];
const hrefMetaData = {};

if (groupedReferences) {
	for (const hrefLink of Object.keys(groupedReferences)) {
		let url: URL;
		try {
			url = new URL(hrefLink);
			urlList.push(url);
			for (const block of groupedReferences[hrefLink]) {
				const result = await getReferenceLink(post.PageId, undefined, block, true);
				blockIdLinks[block.Id] = result[0];
			}
		} catch (err) {
			console.log(err);
			delete groupedReferences[hrefLink];
			continue;
		}
	}
}

const urlMap = await buildURLToHTMLMap(urlList);

const metascraper = createMetascraper([
	metascraperTitle(),
	metascraperImage(),
	metascraperDescription(),
]);

if (groupedReferences && Object.keys(groupedReferences).length > 0 && urlMap) {
	for (const hrefLink of Object.keys(groupedReferences)) {
		let url: URL;
		let metadata: Record<string, string>;
		try {
			url = new URL(hrefLink);
			const html = urlMap[hrefLink];
			if (html) {
				metadata = await metascraper({ html, url });
				if (!metadata || (metadata && !metadata.title)) {
					delete groupedReferences[hrefLink];
					continue;
				} else {
					hrefMetaData[hrefLink] = metadata;
				}
			} else {
				delete groupedReferences[hrefLink];
			}
		} catch (err) {
			console.log(err);
			delete groupedReferences[hrefLink];
			continue;
		}
	}
}
---

{
	groupedReferences && Object.keys(groupedReferences).length > 0 && urlMap && (
		<>
			<details class="toggle no-rss" id="autogenerated-external-links">
				<summary class="flex max-w-full cursor-pointer list-outside list-none gap-2">
					<div class="-ml-7">
						<Icon
							name={"toggle-triangle"}
							class="rotate-svg h-6 w-6 shrink-0 transition-all duration-300"
							aria-label="Toggle open/close"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
						/>
					</div>
					<div>
						<span class="font-semibold">External Links On This Page</span>
					</div>
				</summary>
				<div class="pl-2">
					{Object.entries(groupedReferences).map(([hrefLink, blocks]) => (
						<div>
							<div class="inline-block">
								<a
									href={hrefLink}
									class="text-link hover:decoration-accent-2 no-underline hover:underline hover:underline-offset-4"
								>
									{hrefMetaData[hrefLink].title.length > 35
										? `${hrefMetaData[hrefLink].title.slice(0, 35)}â€¦`
										: hrefMetaData[hrefLink].title}
								</a>
								{" at "}
								{REFERENCES && Object.keys(REFERENCES).length > 0 && REFERENCES["popovers"] ? (
									<>
										{blocks.map((block, index) => (
											<NBlocksPopover
												block={block}
												linkedTo={blockIdLinks[block.Id]}
												popoverSpanText={`[${index + 1}]`}
												isInterlinkedBack={true}
											/>
										))}
									</>
								) : (
									<>
										{blocks.map((block, index) => (
											<a href={blockIdLinks[block.Id]} class="text-link font-mono text-xs">
												{`[${index + 1}]`}
											</a>
										))}
									</>
								)}
							</div>
						</div>
					))}
				</div>
			</details>
			<br />
		</>
	)
}

<style>
	.toggle > summary > a {
		display: inline;
	}
	details[open] > summary > div > .shrink-0.rotate-svg {
		transform: rotate(90deg);
	}
	summary::-webkit-details-marker {
		display: none;
	}
</style>
